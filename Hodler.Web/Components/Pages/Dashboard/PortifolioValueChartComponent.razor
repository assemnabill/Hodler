@using Hodler.Contracts.Portfolio
@using Hodler.Contracts.Portfolio.PortfolioSummary
@using Hodler.Web.Components.Shared.Services
@inject IHodlerApiClient HodlerApi
@inject ISessionService SessionService

<RadzenStack Gap="0" class="rz-p-0 rz-p-md-6 rz-p-lg-12">
    <RadzenChart TooltipTolerance="100">
        <RadzenChartTooltipOptions Shared="@_sharedTooltip"/>
        <RadzenAreaSeries Smooth="@_smooth"
                          Data="@_portfolioPositions"
                          Title="Portfolio Value"
                          CategoryProperty="Date"
                          ValueProperty="Revenue">
            <RadzenMarkers Visible="@_showMarkers" MarkerType="MarkerType.Circle"/>
            <RadzenSeriesDataLabels Visible="@_showDataLabels"/>
            <RadzenLegend Visible="@_showLegend"></RadzenLegend>
        </RadzenAreaSeries>
        <RadzenValueAxis Visible="false"></RadzenValueAxis>
        <RadzenCategoryAxis Visible="false"/>
    </RadzenChart>
</RadzenStack>

@code {
    private TransactionInfoDto[]? _transactions;
    private bool _smooth = true;
    private bool _sharedTooltip = false;
    private bool _showDataLabels = false;
    private bool _showMarkers = true;
    private bool _showLegend = false;
    DataItem[] _portfolioPositions = [];

    protected override async Task OnInitializedAsync()
    {
        var userId = SessionService.GetCurrentUserId();
        var portfolioInfo = await HodlerApi.GetPortfolioInfoAsync(userId);

        _transactions = portfolioInfo?
            .Transactions
            .ToArray() ?? [];
        
        // todo: use to implement different time intervals for visualization
        var step = TimeSpan.FromDays(3 * 30);
        // _portfolioPositions = _transactions
        //     .GroupBy(t => t.Timestamp.Ticks / step.Ticks)
        //     .Select(g => g.Last())
        //     .Select(t =>
        //     {
        //         var date = t.Timestamp.ToLocalTime().Date.ToShortDateString();
        //
        //         return new DataItem
        //         {
        //             Date = date,
        //             Revenue = CalculatePortfolioValueAtTransactionTimePoint(t)
        //         };
        //     })
        //     .ToArray();
        
        _portfolioPositions = _transactions?
            .Select(t => new DataItem
            {
                Date = t.Timestamp.ToLocalTime().Date.ToShortDateString(),
                Revenue = CalculatePortfolioValueAtTransactionTimePoint(t)
            })
            .ToArray()!;
    }

    private decimal CalculatePortfolioValueAtTransactionTimePoint(DateTimeOffset timePoint)
    {
        if (_transactions is null)
        {
            return 0;
        }

        var transactions = _transactions
            .Where(t => t.Timestamp <= timePoint)
            .OrderBy(x => x.Timestamp)
            .ToArray();

        var bought = transactions
            .Where(t => t.Type == TransactionType.Buy)
            .Sum(t => t.BtcAmount);

        var sold = transactions
            .Where(t => t.Type == TransactionType.Sell)
            .Sum(t => t.BtcAmount);

        var positionValue = (bought - sold) * transactions.Last().MarketPrice;

        return positionValue;
    }

    private decimal CalculatePortfolioValueAtTransactionTimePoint(TransactionInfoDto transaction)
    {
        var transactions = _transactions
            .Where(t => t.Timestamp <= transaction.Timestamp)
            .ToArray();

        var bought = transactions
            .Where(t => t.Type == TransactionType.Buy)
            .Sum(t => t.BtcAmount);

        var sold = transactions
            .Where(t => t.Type == TransactionType.Sell)
            .Sum(t => t.BtcAmount);

        var positionValue = (bought - sold) * transaction.MarketPrice;

        return positionValue;
    }

    record DataItem
    {
        public string Date { get; set; }
        public decimal Revenue { get; set; }
    }

}

<style>
    .rz-scheme-pastel .rz-series-0 {
        fill: #27d15217;
        stroke: #27d17f;
    }
</style>